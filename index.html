<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RemindMe - Smart Voice Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Inter', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 25%, #7c3aed  50%, #c026d3 75%, #e11d48 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .glass-container {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
        }
        
        .floating-orb {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            animation: float 6s ease-in-out infinite;
            pointer-events: none;
        }
        
        .orb1 { width: 100px; height: 100px; top: 10%; left: 10%; animation-delay: 0s; }
        .orb2 { width: 150px; height: 150px; top: 60%; right: 15%; animation-delay: 2s; }
        .orb3 { width: 80px; height: 80px; bottom: 20%; left: 20%; animation-delay: 4s; }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-20px) rotate(120deg); }
            66% { transform: translateY(10px) rotate(240deg); }
        }
        
        .mic-button {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 56px;
            margin: 0 auto;
        }
        
        .mic-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #10b981, #059669);
            border-radius: 50%;
            transition: all 0.4s ease;
            z-index: -1;
        }
        
        .mic-button:hover::before {
            transform: scale(1.1);
            box-shadow: 0 20px 40px rgba(16, 185, 129, 0.4);
        }
        
        .mic-button.listening::before {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            animation: pulse-ring 1.5s infinite;
        }
        
        .mic-button.listening {
            animation: breathe 2s infinite;
        }
        
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 40px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        
        @keyframes breathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .conversation-container {
            max-height: 400px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }
        
        .conversation-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .conversation-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .conversation-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .message {
            margin: 16px 0;
            padding: 16px 20px;
            border-radius: 20px;
            max-width: 85%;
            opacity: 0;
            animation: slideIn 0.5s ease forwards;
            position: relative;
            backdrop-filter: blur(10px);
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 6px;
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .app-message {
            background: rgba(255, 255, 255, 0.95);
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 6px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .status-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 50px;
            padding: 12px 24px;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: fit-content;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 12px;
            transition: all 0.3s ease;
        }
        
        .status-ready { 
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
        }
        
        .status-listening { 
            background: linear-gradient(135deg, #ef4444, #dc2626);
            animation: pulse-dot 1s infinite;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }
        
        .status-processing { 
            background: linear-gradient(135deg, #f59e0b, #d97706);
            animation: spin 1s linear infinite;
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
        }
        
        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .reminder-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 24px;
            margin: 16px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .reminder-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #f59e0b, #ef4444, #8b5cf6, #3b82f6);
            background-size: 200% 100%;
            animation: shimmer 3s linear infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .reminder-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
        }
        
        .app-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .app-title {
            background: linear-gradient(135deg, #ffffff, #f0f9ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }
        
        .app-subtitle {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
            font-weight: 400;
            margin-bottom: 20px;
        }
        
        .feature-pill {
            display: inline-flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            padding: 8px 16px;
            margin: 4px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .example-text {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 16px;
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
            text-align: center;
        }
        
        .section-title {
            color: rgba(255, 255, 255, 0.95);
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .countdown-badge {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        
        .reminder-meta {
            color: #6b7280;
            font-size: 0.75rem;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .delete-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: none;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }
        
        .delete-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }
        
        .delete-btn:active {
            transform: scale(0.95);
        }
        
        .confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .confirmation-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .confirmation-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }
        
        .confirmation-modal.show .confirmation-content {
            transform: scale(1);
        }
        
        .confirmation-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
        }
        
        .confirm-btn, .cancel-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        
        .confirm-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }
        
        .cancel-btn {
            background: #f3f4f6;
            color: #374151;
        }
        
        .cancel-btn:hover {
            background: #e5e7eb;
            transform: translateY(-2px);
        }
        
        .mobile-hint {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 12px;
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.875rem;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .glass-container {
                margin: 10px;
                padding: 24px;
            }
            
            .app-title {
                font-size: 2.5rem;
            }
            
            .mic-button {
                width: 120px;
                height: 120px;
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="floating-orb orb1"></div>
    <div class="floating-orb orb2"></div>
    <div class="floating-orb orb3"></div>
    
    <div class="min-h-screen flex items-center justify-center p-4">
        <div class="glass-container rounded-3xl max-w-4xl w-full p-8">
            <div class="app-header">
                <h1 class="app-title">üé§ RemindMe</h1>
                <p class="app-subtitle">Your intelligent voice assistant for seamless reminders</p>
                
                <div class="flex flex-wrap justify-center gap-2">
                    <span class="feature-pill">üåç Timezone Smart</span>
                    <span class="feature-pill">üó£Ô∏è Voice Powered</span>
                    <span class="feature-pill">‚ö° Instant Response</span>
                    <span class="feature-pill">üéØ Context Aware</span>
                </div>
            </div>
            
            <div class="status-bar">
                <span class="status-indicator status-ready" id="statusIndicator"></span>
                <span id="statusText" class="text-white font-medium">Ready to listen - Say "Remind me..."</span>
            </div>
            
            <div class="grid lg:grid-cols-2 gap-8 mt-8">
                <div class="space-y-6">
                    <div class="text-center">
                        <button id="micButton" class="mic-button">üé§</button>
                        <div class="example-text">
                            üí° Try saying: "Remind me to call my mom at 9 PM tomorrow"
                        </div>
                        <div id="mobileHint" class="mobile-hint" style="display: none;">
                            üì± Tap anywhere on the screen to enable voice responses on mobile
                        </div>
                    </div>
                    
                    <div class="glass-container rounded-2xl p-6">
                        <h3 class="section-title">üí¨ Conversation</h3>
                        <div class="conversation-container" id="conversationDisplay">
                            <div class="message app-message">
                                üëã Welcome to RemindMe! I'm your smart voice assistant. Click the microphone and say "Remind me..." followed by what you'd like to remember.
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="space-y-6">
                    <div class="glass-container rounded-2xl p-6">
                        <h3 class="section-title">üìù Your Reminders</h3>
                        <div id="remindersList">
                            <div class="empty-state">
                                <div class="empty-state-icon">üìÖ</div>
                                <p class="font-medium">No reminders yet</p>
                                <p class="text-sm opacity-75">Create your first reminder using voice commands</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="glass-container rounded-2xl p-6">
                        <h3 class="section-title">üìä Quick Stats</h3>
                        <div class="grid grid-cols-2 gap-4 text-center">
                            <div class="bg-white bg-opacity-10 rounded-xl p-4">
                                <div class="text-2xl font-bold text-white" id="totalReminders">0</div>
                                <div class="text-sm text-white opacity-75">Total Reminders</div>
                            </div>
                            <div class="bg-white bg-opacity-10 rounded-xl p-4">
                                <div class="text-2xl font-bold text-white" id="upcomingReminders">0</div>
                                <div class="text-sm text-white opacity-75">Upcoming</div>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <div class="text-sm text-white opacity-75">
                                üåç Current timezone: <span id="currentTimezone" class="font-medium"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="deleteModal" class="confirmation-modal">
        <div class="confirmation-content">
            <div class="text-4xl mb-4">üóëÔ∏è</div>
            <h3 class="text-xl font-semibold text-gray-900 mb-2">Delete Reminder?</h3>
            <p class="text-gray-600 mb-4" id="deleteMessage">Are you sure you want to delete this reminder?</p>
            <div class="confirmation-buttons">
                <button class="cancel-btn" onclick="app.cancelDelete()">Cancel</button>
                <button class="confirm-btn" onclick="app.confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        let app; // Global reference for onclick handlers
        
        console.log('Script starting...');
        
        class RemindMeApp {
            constructor() {
                console.log('RemindMeApp constructor called');
                
                this.recognition = null;
                this.isListening = false;
                this.conversationState = 'waiting';
                this.currentReminder = {};
                this.reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                this.userLocation = null;
                this.userTimezone = null;
                this.pendingDeleteId = null;
                this.speechEnabled = false;
                this.preferredVoice = null;
                this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                this.initializeElements();
                this.initializeSpeechRecognition();
                this.setupEventListeners();
                this.updateRemindersDisplay();
                this.initializeSpeechSynthesis();
                this.getUserLocation();
                this.updateStats();
                this.setupMobileSupport();
            }
            
            initializeElements() {
                console.log('Initializing elements...');
                this.micButton = document.getElementById('micButton');
                this.statusText = document.getElementById('statusText');
                this.statusIndicator = document.getElementById('statusIndicator');
                this.conversationDisplay = document.getElementById('conversationDisplay');
                this.remindersList = document.getElementById('remindersList');
                this.deleteModal = document.getElementById('deleteModal');
                this.deleteMessage = document.getElementById('deleteMessage');
                
                if (!this.micButton) {
                    console.error('Microphone button not found!');
                } else {
                    console.log('Microphone button found');
                }
            }
            
            setupEventListeners() {
                console.log('Setting up event listeners...');
                if (this.micButton) {
                    this.micButton.addEventListener('click', () => {
                        console.log('Microphone button clicked');
                        this.toggleListening();
                    });
                    console.log('Click listener added to microphone button');
                } else {
                    console.error('Cannot add event listener - microphone button is null');
                }
            }
            
            toggleListening() {
                console.log('Toggle listening called, isListening:', this.isListening);
                if (this.isListening) {
                    this.recognition.stop();
                } else {
                    this.recognition.start();
                }
            }
            
            initializeSpeechRecognition() {
                console.log('Initializing speech recognition...');
                if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                    this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    this.recognition.continuous = false;
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';
                    
                    this.recognition.onstart = () => this.onRecognitionStart();
                    this.recognition.onend = () => this.onRecognitionEnd();
                    this.recognition.onresult = (event) => this.onRecognitionResult(event);
                    this.recognition.onerror = (event) => this.onRecognitionError(event);
                    
                    console.log('Speech recognition initialized');
                } else {
                    console.error('Speech recognition not supported');
                    this.showMessage('app', '‚ùå Speech recognition not supported in this browser. Please use Chrome.');
                    this.micButton.disabled = true;
                }
            }
            
            onRecognitionStart() {
                console.log('Recognition started');
                this.isListening = true;
                this.micButton.className = 'mic-button listening';
                this.statusText.textContent = 'Listening... Speak now';
                this.statusIndicator.className = 'status-indicator status-listening';
            }
            
            onRecognitionEnd() {
                console.log('Recognition ended');
                this.isListening = false;
                this.micButton.className = 'mic-button';
                this.statusText.textContent = 'Ready to listen - Say "Remind me..."';
                this.statusIndicator.className = 'status-indicator status-ready';
            }
            
            onRecognitionResult(event) {
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    }
                }
                
                if (finalTranscript) {
                    const transcript = finalTranscript.trim();
                    this.showMessage('user', transcript);
                    this.processUserInput(transcript);
                }
            }
            
            onRecognitionError(event) {
                console.error('Recognition error:', event.error);
                if (event.error !== 'no-speech') {
                    this.showMessage('app', `‚ùå Error: ${event.error}. Please try again.`);
                }
            }
            
            processUserInput(input) {
                this.statusIndicator.className = 'status-indicator status-processing';
                
                if (this.isListening) {
                    this.recognition.stop();
                }
                
                this.handleConversationFlow(input.toLowerCase());
            }
            
            handleConversationFlow(input) {
                switch (this.conversationState) {
                    case 'waiting':
                        this.handleInitialInput(input);
                        break;
                    case 'confirm_reminder':
                        this.handleConfirmation(input);
                        break;
                    case 'get_task':
                        this.handleTaskInput(input);
                        break;
                    case 'get_time':
                        this.handleTimeInput(input);
                        break;
                    case 'get_date':
                        this.handleDateInput(input);
                        break;
                    case 'get_datetime':
                        this.handleDateTimeInput(input);
                        break;
                }
            }
            
            handleInitialInput(input) {
                const reminderKeywords = ['remind me that', 'remind me to', 'remind me'];
                let content = input;
                let isReminderIntent = false;

                for (const keyword of reminderKeywords) {
                    if (input.startsWith(keyword)) {
                        isReminderIntent = true;
                        content = input.substring(keyword.length).trim();
                        break;
                    }
                }

                if (!isReminderIntent && (this.extractDate(input) || this.extractTime(input))) {
                    isReminderIntent = true;
                }

                if (isReminderIntent && content) {
                    this.processReminderContent(content);
                } else if (isReminderIntent && !content) {
                    this.conversationState = 'get_task';
                    const message = '‚úÖ Great! What should I remind you about?';
                    this.showMessage('app', message);
                    this.speak(message, () => this.startListeningAgain());
                } else {
                    this.conversationState = 'confirm_reminder';
                    const message = `ü§î I'm not sure what you mean. Did you want to set a reminder? Please say "yes" or "no".`;
                    this.showMessage('app', message);
                    this.speak(message, () => this.startListeningAgain());
                }
            }
            
            handleConfirmation(input) {
                if (input.includes('yes') || input.includes('yeah') || input.includes('yep')) {
                    this.conversationState = 'get_task';
                    const message = '‚úÖ Tell me what I should remind you later.';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else if (input.includes('no') || input.includes('nope')) {
                    this.conversationState = 'waiting';
                    const message = 'üëç OK, whenever you need a reminder, just let me know!';
                    this.showMessage('app', message);
                    this.speak(message);
                    this.statusIndicator.className = 'status-indicator status-ready';
                } else {
                    const message = 'ü§∑‚Äç‚ôÄÔ∏è Please say "yes" or "no".';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            // --- FIX 1: This function is now much smarter ---
            handleTaskInput(input) {
                // Instead of just setting the task, we process the whole sentence
                // to see if date/time are also included.
                this.processReminderContent(input);
            }
            
            handleTimeInput(input) {
                const timeInfo = this.extractTime(input);
                if (timeInfo || this.isTimeResponse(input)) {
                    this.currentReminder.time = timeInfo || input;
                    if (!this.currentReminder.date) {
                        this.conversationState = 'get_date';
                        const message = 'üìÖ When should I remind you? (today, tomorrow, Monday, etc.)';
                        this.showMessage('app', message);
                        this.speak(message, () => {
                            this.startListeningAgain();
                        });
                    } else {
                        this.createReminder();
                    }
                } else {
                    const message = '‚è∞ I couldn\'t understand the time. Please say it again (e.g., "9 PM", "3:30 PM")';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            handleDateInput(input) {
                const dateInfo = this.extractDate(input);
                if (dateInfo || this.isDateResponse(input)) {
                    this.currentReminder.date = dateInfo || input;
                    if (!this.currentReminder.time) {
                        this.conversationState = 'get_time';
                        const message = '‚è∞ What time should I remind you?';
                        this.showMessage('app', message);
                        this.speak(message, () => {
                            this.startListeningAgain();
                        });
                    } else {
                        this.createReminder();
                    }
                } else {
                    const message = 'üìÖ I couldn\'t understand the date. Please say it again (e.g., "today", "tomorrow", "Monday")';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            handleDateTimeInput(input) {
                const timeInfo = this.extractTime(input);
                const dateInfo = this.extractDate(input);
                
                if (timeInfo || dateInfo || this.isTimeResponse(input) || this.isDateResponse(input)) {
                    if (timeInfo || this.isTimeResponse(input)) {
                        this.currentReminder.time = timeInfo || input;
                    }
                    if (dateInfo || this.isDateResponse(input)) {
                        this.currentReminder.date = dateInfo || input;
                    }
                    
                    if (!this.currentReminder.time) {
                        this.conversationState = 'get_time';
                        const message = '‚è∞ What time should I remind you?';
                        this.showMessage('app', message);
                        this.speak(message, () => {
                            this.startListeningAgain();
                        });
                    } else if (!this.currentReminder.date) {
                        this.conversationState = 'get_date';
                        const message = 'üìÖ When should I remind you? (today, tomorrow, Monday, etc.)';
                        this.showMessage('app', message);
                        this.speak(message, () => {
                            this.startListeningAgain();
                        });
                    } else {
                        this.createReminder();
                    }
                } else {
                    const message = 'ü§î I couldn\'t understand. Please tell me when and at what time you want to be reminded.';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            isTimeResponse(input) {
                return input.match(/(\d{1,2}):(\d{2})\s*(a\.?m\.?|p\.?m\.?|am|pm)?\s*(is\s*(perfect|good|fine|okay|ok))?/i) ||
                       input.match(/(\d{1,2})\s*(a\.?m\.?|p\.?m\.?|am|pm)\s*(is\s*(perfect|good|fine|okay|ok))?/i) ||
                       input.includes('o\'clock') ||
                       input.includes('o clock');
            }
            
            isDateResponse(input) {
                return input.match(/(\d+)\s*days?\s*(later|from\s*(now|today))?/i) ||
                       input.match(/(\d+)\s*weeks?\s*(later|from\s*(now|today))?/i) ||
                       ['today', 'tomorrow', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].some(day => input.includes(day));
            }
            
            processReminderContent(content) {
                this.currentReminder = {};
                
                let task = content;
                 // Clean keywords from the task content itself
                task = task.replace(/remind me that/gi, '').replace(/remind me to/gi, '').replace(/remind me/gi, '').trim();

                const timeInfo = this.extractTime(task);
                const dateInfo = this.extractDate(task);
                
                if (timeInfo) {
                    task = task.replace(timeInfo, '').trim();
                }
                if (dateInfo) {
                    task = task.replace(dateInfo, '').trim();
                }
                
                task = task.replace(/\s+at\s*$/i, '')
                           .replace(/\s+on\s*$/i, '')
                           .replace(/\s+in\s*$/i, '')
                           .replace(/\s+to\s*$/i, '')
                           .trim();
                
                this.currentReminder.task = task;
                this.currentReminder.time = timeInfo;
                this.currentReminder.date = dateInfo;
                
                this.analyzeTimeAndDate(content);
            }
            
            analyzeTimeAndDate(content) {
                if (!this.currentReminder.task) {
                    this.conversationState = 'get_task';
                    const message = '‚úÖ What should I remind you about?';
                    this.showMessage('app', message);
                    this.speak(message, () => this.startListeningAgain());
                } else if (!this.currentReminder.time && !this.currentReminder.date) {
                    this.conversationState = 'get_datetime';
                    const message = '‚è∞ When and at what time should I remind you?';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else if (!this.currentReminder.time) {
                    this.conversationState = 'get_time';
                    const message = '‚è∞ What time should I remind you?';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else if (!this.currentReminder.date) {
                    this.conversationState = 'get_date';
                    const message = 'üìÖ When should I remind you? (today, tomorrow, Monday, etc.)';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else {
                    this.createReminder();
                }
            }
            
            extractTime(text) {
                const timePatterns = [
                    /(\d{1,2}):(\d{2})\s*(a\.?m\.?|p\.?m\.?|am|pm)/i,
                    /(\d{1,2})\s*(a\.?m\.?|p\.?m\.?|am|pm)/i,
                    /(\d{1,2}):(\d{2})/,
                    /(\d{1,2})\s*o'?clock/i
                ];
                
                for (const pattern of timePatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return match[0];
                    }
                }
                
                const spokenTimes = {
                    'one': '1', 'two': '2', 'three': '3', 'four': '4',
                    'five': '5', 'six': '6', 'seven': '7', 'eight': '8',
                    'nine': '9', 'ten': '10', 'eleven': '11', 'twelve': '12'
                };
                
                for (const [word, number] of Object.entries(spokenTimes)) {
                    const pattern = new RegExp(`\\b${word}\\b\\s*(o'?clock|a\\.?m\\.?|p\\.?m\\.?|am|pm)?`, 'i');
                    const match = text.match(pattern);
                    if (match) {
                        const ampm = (match[1] || '').toLowerCase();
                        if (ampm.includes('p')) return `${number} PM`;
                        if (ampm.includes('a')) return `${number} AM`;
                        return `${number}:00`;
                    }
                }
                
                return null;
            }
            
            extractDate(text) {
                const lowerText = text.toLowerCase();
                
                if (lowerText.includes('today')) return 'today';
                if (lowerText.includes('tomorrow')) return 'tomorrow';
                
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                for (const day of days) {
                    if (lowerText.includes(`next ${day}`)) return `next ${day}`;
                    if (lowerText.includes(day)) return day;
                }
                
                const daysMatch = lowerText.match(/(\d+)\s*days?\s*(later|from\s*(now|today))?/);
                if (daysMatch) {
                    const days = parseInt(daysMatch[1]);
                    return `${days} days later`;
                }
                
                const weeksMatch = lowerText.match(/(\d+)\s*weeks?\s*(later|from\s*(now|today))?/);
                if (weeksMatch) {
                    const weeks = parseInt(weeksMatch[1]);
                    return `${weeks} weeks later`;
                }
                
                if (lowerText.includes('next week')) return 'next week';
                if (lowerText.includes('next month')) return 'next month';
                if (lowerText.includes('this week')) return 'this week';
                if (lowerText.includes('this weekend')) return 'this weekend';
                if (lowerText.includes('next weekend')) return 'next weekend';
                
                return null;
            }
            
            parseDateTime(dateStr, timeStr) {
                const now = new Date();
                let targetDate = new Date(now);
                
                if (dateStr) {
                    const lowerDate = dateStr.toLowerCase();
                    
                    if (lowerDate === 'today') {
                        // Keep current date
                    } else if (lowerDate === 'tomorrow') {
                        targetDate.setDate(targetDate.getDate() + 1);
                    } else if (lowerDate.includes('days later')) {
                        const daysMatch = lowerDate.match(/(\d+)/);
                        if (daysMatch) targetDate.setDate(targetDate.getDate() + parseInt(daysMatch[1]));
                    } else if (lowerDate.includes('weeks later')) {
                        const weeksMatch = lowerDate.match(/(\d+)/);
                        if (weeksMatch) targetDate.setDate(targetDate.getDate() + (parseInt(weeksMatch[1]) * 7));
                    } else if (lowerDate === 'next week') {
                        targetDate.setDate(targetDate.getDate() + 7);
                    } else if (lowerDate === 'next month') {
                        targetDate.setMonth(targetDate.getMonth() + 1);
                    } else if (lowerDate === 'this weekend' || lowerDate === 'next weekend') {
                        const isNext = lowerDate.includes('next');
                        let daysUntilSaturday = (6 - now.getDay() + 7) % 7;
                        if (daysUntilSaturday === 0 && now.getHours() >= 17) daysUntilSaturday = 7; 
                        targetDate.setDate(targetDate.getDate() + daysUntilSaturday + (isNext ? 7 : 0));
                    } else {
                        const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                        const targetDayIndex = days.findIndex(day => lowerDate.includes(day));
                        if (targetDayIndex !== -1) {
                            const currentDay = now.getDay();
                            let daysUntil = (targetDayIndex - currentDay + 7) % 7;
                            if (daysUntil === 0 && !lowerDate.includes('today')) { 
                                daysUntil = 7;
                            }
                            if (lowerDate.includes('next')) {
                                daysUntil += 7;
                            }
                            targetDate.setDate(targetDate.getDate() + daysUntil);
                        }
                    }
                }
                
                if (timeStr) {
                    const cleanTime = timeStr.replace(/is\s*(perfect|good|fine|okay|ok)/gi, '').trim();
                    const timeMatch = cleanTime.match(/(\d{1,2})(?::(\d{2}))?\s*(a\.?m\.?|p\.?m\.?|am|pm)?/i);
                    if (timeMatch) {
                        let hours = parseInt(timeMatch[1], 10);
                        const minutes = parseInt(timeMatch[2] || '0', 10);
                        const ampm = timeMatch[3] ? timeMatch[3].toLowerCase().replace(/\./g, '') : '';
                        
                        if (ampm.includes('p') && hours < 12) {
                            hours += 12;
                        } else if (ampm.includes('a') && hours === 12) {
                            hours = 0;
                        }
                        
                        targetDate.setHours(hours, minutes, 0, 0);
                    }
                }
                
                return targetDate;
            }
            
            createReminder() {
                if (this.currentReminder.time) {
                    this.currentReminder.time = this.currentReminder.time.replace(/is\s*(perfect|good|fine|okay|ok)/gi, '').trim();
                }
                if (this.currentReminder.date) {
                    this.currentReminder.date = this.currentReminder.date.replace(/from\s*(today|now)/gi, '').trim();
                }
                
                const reminderDateTime = this.parseDateTime(this.currentReminder.date, this.currentReminder.time);
                
                const reminder = {
                    id: Date.now(),
                    task: this.currentReminder.task,
                    time: this.currentReminder.time,
                    date: this.currentReminder.date,
                    timestamp: reminderDateTime.getTime(),
                    timezone: this.userTimezone,
                    created: new Date().toLocaleString(),
                    location: this.userLocation
                };
                
                const isDuplicate = this.reminders.some(existing => 
                    existing.task.toLowerCase() === reminder.task.toLowerCase() && 
                    Math.abs(existing.timestamp - reminder.timestamp) < 60000
                );
                
                if (isDuplicate) {
                    const message = '‚ö†Ô∏è This reminder already exists!';
                    this.showMessage('app', message);
                    this.speak(message);
                    this.resetState();
                    return;
                }
                
                this.reminders.push(reminder);
                localStorage.setItem('reminders', JSON.stringify(this.reminders));
                
                const formattedDateTime = this.formatReminderDateTime(reminder.timestamp);
                const message = `‚úÖ Perfect! I've created your reminder: "${reminder.task}" for ${formattedDateTime}.`;
                this.showMessage('app', message);
                this.speak(message);
                
                this.updateRemindersDisplay();
                this.updateStats();
                this.resetState();
                this.statusIndicator.className = 'status-indicator status-ready';
            }
            
            formatReminderDateTime(timestamp) {
                if (!timestamp) return 'N/A';
                
                const date = new Date(timestamp);
                const options = {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true,
                    timeZoneName: 'short'
                };
                
                return date.toLocaleString(undefined, options);
            }
            
            resetState() {
                this.conversationState = 'waiting';
                this.currentReminder = {};
            }
            
            startListeningAgain() {
                setTimeout(() => {
                    if (!this.isListening) {
                        this.recognition.start();
                    }
                }, 500);
            }
            
            showMessage(sender, message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}-message`;
                messageDiv.textContent = message;
                this.conversationDisplay.appendChild(messageDiv);
                this.conversationDisplay.scrollTop = this.conversationDisplay.scrollHeight;
            }
            
            initializeSpeechSynthesis() {
                this.synth = window.speechSynthesis;
                
                if ('speechSynthesis' in window) {
                    const loadVoices = () => {
                        const voices = this.synth.getVoices();
                        console.log('Available voices:', voices.length);
                        
                        this.preferredVoice = voices.find(voice => voice.name === 'Google US English') ||
                                              voices.find(voice => voice.lang.startsWith('en-US') && voice.name.includes('Google')) ||
                                              voices.find(voice => voice.lang.startsWith('en-US') && voice.localService) ||
                                              voices.find(voice => voice.lang.startsWith('en-US'));

                        if (this.preferredVoice) {
                            console.log('Preferred voice selected:', this.preferredVoice.name, this.preferredVoice);
                        }
                    };
                    
                    loadVoices();
                    if (this.synth.onvoiceschanged !== undefined) {
                       this.synth.onvoiceschanged = loadVoices;
                    }
                }
                
                if (!this.isMobile) {
                    this.speechEnabled = true;
                } else {
                    console.log('Mobile device detected, speech will be enabled after user interaction');
                }
            }
            
            speak(text, callback = null) {
                if (!this.speechEnabled) {
                    console.log('Speech not enabled yet, skipping:', text);
                    if (callback) callback();
                    return;
                }

                this.synth.cancel();

                setTimeout(() => {
                    // --- FIX 2: Strip emojis from the text before speaking ---
                    const emojiRegex = /(\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/g;
                    const cleanText = text.replace(emojiRegex, '').trim();

                    const utterance = new SpeechSynthesisUtterance(cleanText);

                    if (this.preferredVoice) {
                        utterance.voice = this.preferredVoice;
                    }

                    utterance.volume = 1.0; 
                    utterance.rate = 0.95; 
                    utterance.pitch = 1.0; 

                    utterance.onend = () => {
                        if (callback) callback();
                    };

                    utterance.onerror = (event) => {
                        console.error('Speech synthesis error:', event.error);
                        if (callback) callback();
                    };

                    try {
                        this.synth.speak(utterance);
                    } catch (error) {
                        console.error('Failed to speak:', error);
                        if (callback) callback();
                    }
                }, 50);
            }
            
            setupMobileSupport() {
                if (this.isMobile) {
                    document.getElementById('mobileHint').style.display = 'block';
                    
                    const enableSpeech = () => {
                        if (!this.speechEnabled) {
                            this.speechEnabled = true;
                            console.log('Speech synthesis enabled for mobile by user interaction.');
                            document.getElementById('mobileHint').style.display = 'none';
                            
                            const utterance = new SpeechSynthesisUtterance(' ');
                            utterance.volume = 0;
                            this.synth.speak(utterance);

                            this.showMessage('app', 'üîä Voice responses are now enabled!');
                        }
                    };
                    
                    document.addEventListener('click', enableSpeech, { once: true });
                    document.addEventListener('touchstart', enableSpeech, { once: true });
                }
            }
            
            async getUserLocation() {
                try {
                    this.userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    document.getElementById('currentTimezone').textContent = this.userTimezone;
                    
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                this.userLocation = {
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    timezone: this.userTimezone
                                };
                            },
                            (error) => {
                                console.log('Geolocation not available, using system timezone');
                            }
                        );
                    }
                } catch (error) {
                    this.userTimezone = 'UTC';
                    document.getElementById('currentTimezone').textContent = 'UTC';
                }
            }
            
            updateRemindersDisplay() {
                this.reminders.sort((a, b) => a.timestamp - b.timestamp);

                if (this.reminders.length === 0) {
                    this.remindersList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÖ</div>
                            <p class="font-medium">No reminders yet</p>
                            <p class="text-sm opacity-75">Create your first reminder using voice commands</p>
                        </div>
                    `;
                } else {
                    this.remindersList.innerHTML = this.reminders.map(reminder => {
                        const formattedTime = reminder.timestamp ? 
                            this.formatReminderDateTime(reminder.timestamp) : 
                            `${reminder.date} at ${reminder.time}`;
                        
                        const timeUntil = reminder.timestamp ? this.getTimeUntilReminder(reminder.timestamp) : '';
                        
                        return `
                            <div class="reminder-card" id="reminder-${reminder.id}">
                                <div class="flex items-start justify-between">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-900 text-lg mb-2">${reminder.task}</h4>
                                        <p class="text-gray-600 text-sm flex items-center gap-2">
                                            <span>üìÖ</span>
                                            ${formattedTime}
                                        </p>
                                        ${timeUntil ? `<div class="countdown-badge">${timeUntil}</div>` : ''}
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <div class="text-2xl opacity-50">‚è∞</div>
                                        <button 
                                            class="delete-btn"
                                            onclick="app.deleteReminder(${reminder.id})"
                                            title="Delete reminder"
                                        >
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                </div>
                                <div class="reminder-meta">
                                    <div class="flex items-center justify-between text-xs">
                                        <span>Created: ${reminder.created}</span>
                                        ${reminder.timezone ? `<span class="flex items-center gap-1"><span>üåç</span>${reminder.timezone}</span>` : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            }
            
            getTimeUntilReminder(timestamp) {
                const now = new Date().getTime();
                const diff = timestamp - now;
                
                if (diff < 0) return '‚è∞ Overdue';
                
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                
                if (days > 0) return `‚è≥ In ${days}d ${hours}h`;
                if (hours > 0) return `‚è≥ In ${hours}h ${minutes}m`;
                if (minutes > 0) return `‚è≥ In ${minutes}m`;
                return 'üî• Any moment now!';
            }
            
            updateStats() {
                const total = this.reminders.length;
                const upcoming = this.reminders.filter(r => r.timestamp > new Date().getTime()).length;
                
                document.getElementById('totalReminders').textContent = total;
                document.getElementById('upcomingReminders').textContent = upcoming;
            }
            
            deleteReminder(id) {
                const reminder = this.reminders.find(r => r.id === id);
                if (reminder) {
                    this.pendingDeleteId = id;
                    this.deleteMessage.textContent = `Are you sure you want to delete "${reminder.task}"?`;
                    this.deleteModal.classList.add('show');
                }
            }
            
            confirmDelete() {
                if (this.pendingDeleteId) {
                    this.reminders = this.reminders.filter(r => r.id !== this.pendingDeleteId);
                    localStorage.setItem('reminders', JSON.stringify(this.reminders));
                    
                    const reminderCard = document.getElementById(`reminder-${this.pendingDeleteId}`);
                    if (reminderCard) {
                        reminderCard.style.transform = 'translateX(-100%)';
                        reminderCard.style.opacity = '0';
                        
                        setTimeout(() => {
                            this.updateRemindersDisplay();
                            this.updateStats();
                        }, 300);
                    } else {
                        this.updateRemindersDisplay();
                        this.updateStats();
                    }
                    
                    this.showMessage('app', '‚úÖ Reminder deleted successfully!');
                    this.speak('Reminder deleted successfully!');
                    
                    this.cancelDelete();
                }
            }
            
            cancelDelete() {
                this.deleteModal.classList.remove('show');
                this.pendingDeleteId = null;
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, creating app...');
            app = new RemindMeApp();
            console.log('App created');
        });
    </script>
</body>
</html>
