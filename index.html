<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RemindMe - Smart Voice Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'Inter', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 25%, #7c3aed  50%, #c026d3 75%, #e11d48 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .glass-container {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
        }
        
        .floating-orb {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            animation: float 6s ease-in-out infinite;
            pointer-events: none;
        }
        
        .orb1 { width: 100px; height: 100px; top: 10%; left: 10%; animation-delay: 0s; }
        .orb2 { width: 150px; height: 150px; top: 60%; right: 15%; animation-delay: 2s; }
        .orb3 { width: 80px; height: 80px; bottom: 20%; left: 20%; animation-delay: 4s; }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-20px) rotate(120deg); }
            66% { transform: translateY(10px) rotate(240deg); }
        }
        
        .mic-button {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 56px;
            margin: 0 auto;
        }
        
        .mic-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #10b981, #059669);
            border-radius: 50%;
            transition: all 0.4s ease;
            z-index: -1;
        }
        
        .mic-button:hover::before {
            transform: scale(1.1);
            box-shadow: 0 20px 40px rgba(16, 185, 129, 0.4);
        }
        
        .mic-button.listening::before {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            animation: pulse-ring 1.5s infinite;
        }
        
        .mic-button.listening {
            animation: breathe 2s infinite;
        }
        
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 40px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        
        @keyframes breathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .conversation-container {
            max-height: 400px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }
        
        .conversation-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .conversation-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .conversation-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .message {
            margin: 16px 0;
            padding: 16px 20px;
            border-radius: 20px;
            max-width: 85%;
            opacity: 0;
            animation: slideIn 0.5s ease forwards;
            position: relative;
            backdrop-filter: blur(10px);
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 6px;
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .app-message {
            background: rgba(255, 255, 255, 0.95);
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 6px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .status-bar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 50px;
            padding: 12px 24px;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: fit-content;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 12px;
            transition: all 0.3s ease;
        }
        
        .status-ready { 
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
        }
        
        .status-listening { 
            background: linear-gradient(135deg, #ef4444, #dc2626);
            animation: pulse-dot 1s infinite;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }
        
        .status-processing { 
            background: linear-gradient(135deg, #f59e0b, #d97706);
            animation: spin 1s linear infinite;
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
        }
        
        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .reminder-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 24px;
            margin: 16px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .reminder-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #f59e0b, #ef4444, #8b5cf6, #3b82f6);
            background-size: 200% 100%;
            animation: shimmer 3s linear infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .reminder-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
        }
        
        .app-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .app-title {
            background: linear-gradient(135deg, #ffffff, #f0f9ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: -0.02em;
        }
        
        .app-subtitle {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
            font-weight: 400;
            margin-bottom: 20px;
        }
        
        .feature-pill {
            display: inline-flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            padding: 8px 16px;
            margin: 4px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .example-text {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 16px;
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
            text-align: center;
        }
        
        .section-title {
            color: rgba(255, 255, 255, 0.95);
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.7;
        }
        
        .countdown-badge {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        
        .reminder-meta {
            color: #6b7280;
            font-size: 0.75rem;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .delete-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: none;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }
        
        .delete-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }
        
        .delete-btn:active {
            transform: scale(0.95);
        }
        
        .confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .confirmation-modal.show {
            opacity: 1;
            visibility: visible;
        }
        
        .confirmation-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }
        
        .confirmation-modal.show .confirmation-content {
            transform: scale(1);
        }
        
        .confirmation-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
        }
        
        .confirm-btn, .cancel-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        
        .confirm-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .confirm-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }
        
        .cancel-btn {
            background: #f3f4f6;
            color: #374151;
        }
        
        .cancel-btn:hover {
            background: #e5e7eb;
            transform: translateY(-2px);
        }
        
        .mobile-hint {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 12px;
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.875rem;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .glass-container {
                margin: 10px;
                padding: 24px;
            }
            
            .app-title {
                font-size: 2.5rem;
            }
            
            .mic-button {
                width: 120px;
                height: 120px;
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <!-- Floating background orbs -->
    <div class="floating-orb orb1"></div>
    <div class="floating-orb orb2"></div>
    <div class="floating-orb orb3"></div>
    
    <div class="min-h-screen flex items-center justify-center p-4">
        <div class="glass-container rounded-3xl max-w-4xl w-full p-8">
            <!-- Header -->
            <div class="app-header">
                <h1 class="app-title">üé§ RemindMe</h1>
                <p class="app-subtitle">Your intelligent voice assistant for seamless reminders</p>
                
                <div class="flex flex-wrap justify-center gap-2">
                    <span class="feature-pill">üåç Timezone Smart</span>
                    <span class="feature-pill">üó£Ô∏è Voice Powered</span>
                    <span class="feature-pill">‚ö° Instant Response</span>
                    <span class="feature-pill">üéØ Context Aware</span>
                </div>
            </div>
            
            <!-- Status Bar -->
            <div class="status-bar">
                <span class="status-indicator status-ready" id="statusIndicator"></span>
                <span id="statusText" class="text-white font-medium">Ready to listen - Say "Remind me that..."</span>
            </div>
            
            <!-- Main Interface -->
            <div class="grid lg:grid-cols-2 gap-8 mt-8">
                <!-- Voice Interface -->
                <div class="space-y-6">
                    <div class="text-center">
                        <button id="micButton" class="mic-button">üé§</button>
                        <div class="example-text">
                            üí° Try saying: "Remind me to call mom tomorrow at 7 PM"
                        </div>
                        <!-- Mobile hint will be added here -->
                        <div id="mobileHint" class="mobile-hint" style="display: none;">
                            üì± Tap anywhere to enable voice responses on mobile
                        </div>
                    </div>
                    
                    <!-- Conversation Display -->
                    <div class="glass-container rounded-2xl p-6">
                        <h3 class="section-title">üí¨ Conversation</h3>
                        <div class="conversation-container" id="conversationDisplay">
                            <div class="message app-message">
                                üëã Welcome to RemindMe! I'm your smart voice assistant. Click the microphone and say "Remind me that..." followed by what you'd like to remember.
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Reminders Panel -->
                <div class="space-y-6">
                    <div class="glass-container rounded-2xl p-6">
                        <h3 class="section-title">üìù Your Reminders</h3>
                        <div id="remindersList">
                            <div class="empty-state">
                                <div class="empty-state-icon">üìÖ</div>
                                <p class="font-medium">No reminders yet</p>
                                <p class="text-sm opacity-75">Create your first reminder using voice commands</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Quick Stats -->
                    <div class="glass-container rounded-2xl p-6">
                        <h3 class="section-title">üìä Quick Stats</h3>
                        <div class="grid grid-cols-2 gap-4 text-center">
                            <div class="bg-white bg-opacity-10 rounded-xl p-4">
                                <div class="text-2xl font-bold text-white" id="totalReminders">0</div>
                                <div class="text-sm text-white opacity-75">Total Reminders</div>
                            </div>
                            <div class="bg-white bg-opacity-10 rounded-xl p-4">
                                <div class="text-2xl font-bold text-white" id="upcomingReminders">0</div>
                                <div class="text-sm text-white opacity-75">Upcoming</div>
                            </div>
                        </div>
                        <div class="mt-4 text-center">
                            <div class="text-sm text-white opacity-75">
                                üåç Current timezone: <span id="currentTimezone" class="font-medium"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div id="deleteModal" class="confirmation-modal">
        <div class="confirmation-content">
            <div class="text-4xl mb-4">üóëÔ∏è</div>
            <h3 class="text-xl font-semibold text-gray-900 mb-2">Delete Reminder?</h3>
            <p class="text-gray-600 mb-4" id="deleteMessage">Are you sure you want to delete this reminder?</p>
            <div class="confirmation-buttons">
                <button class="cancel-btn" onclick="app.cancelDelete()">Cancel</button>
                <button class="confirm-btn" onclick="app.confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        let app; // Global reference for onclick handlers
        class RemindMeApp {
            constructor() {
                this.recognition = null;
                this.isListening = false;
                this.conversationState = 'waiting';
                this.currentReminder = {};
                this.reminders = JSON.parse(localStorage.getItem('reminders') || '[]');
                this.userLocation = null;
                this.userTimezone = null;
                this.pendingDeleteId = null;
                this.speechEnabled = false; // Track if speech is enabled for mobile
                this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                this.initializeElements();
                this.initializeSpeechRecognition();
                this.setupEventListeners();
                this.updateRemindersDisplay();
                this.initializeSpeechSynthesis();
                this.getUserLocation();
                this.updateStats();
                this.setupMobileSupport();
            }
            
            setupMobileSupport() {
                if (this.isMobile) {
                    // Show mobile hint
                    document.getElementById('mobileHint').style.display = 'block';
                    
                    // Enable speech on any user interaction
                    const enableSpeech = () => {
                        if (!this.speechEnabled) {
                            // Play silent utterance to wake up speech synthesis
                            const utterance = new SpeechSynthesisUtterance('');
                            utterance.volume = 0;
                            this.synth.speak(utterance);
                            this.speechEnabled = true;
                            
                            // Hide mobile hint
                            document.getElementById('mobileHint').style.display = 'none';
                            console.log('Speech synthesis enabled for mobile');
                        }
                    };
                    
                    // Add event listeners for various interactions
                    document.addEventListener('touchstart', enableSpeech, { once: true });
                    document.addEventListener('click', enableSpeech, { once: true });
                    this.micButton.addEventListener('click', enableSpeech, { once: true });
                }
            }
            
            async getUserLocation() {
                try {
                    this.userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    document.getElementById('currentTimezone').textContent = this.userTimezone;
                    
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                this.userLocation = {
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    timezone: this.userTimezone
                                };
                            },
                            (error) => {
                                console.log('Geolocation not available, using system timezone');
                            }
                        );
                    }
                } catch (error) {
                    this.userTimezone = 'UTC';
                    document.getElementById('currentTimezone').textContent = 'UTC';
                }
            }
            
            initializeElements() {
                this.micButton = document.getElementById('micButton');
                this.statusText = document.getElementById('statusText');
                this.statusIndicator = document.getElementById('statusIndicator');
                this.conversationDisplay = document.getElementById('conversationDisplay');
                this.remindersList = document.getElementById('remindersList');
                this.deleteModal = document.getElementById('deleteModal');
                this.deleteMessage = document.getElementById('deleteMessage');
            }
            
            initializeSpeechSynthesis() {
                this.synth = window.speechSynthesis;
                
                // For desktop, enable speech immediately
                if (!this.isMobile) {
                    this.speechEnabled = true;
                }
            }
            
            speak(text, callback = null) {
                // Auto-enable speech for mobile if not already enabled
                if (this.isMobile && !this.speechEnabled) {
                    const utterance = new SpeechSynthesisUtterance('');
                    utterance.volume = 0;
                    this.synth.speak(utterance);
                    this.speechEnabled = true;
                }
                
                // Cancel any ongoing speech
                this.synth.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                
                // Mobile-optimized settings
                if (this.isMobile) {
                    utterance.rate = 0.9; // Slightly slower for mobile
                    utterance.pitch = 1.1; // Higher pitch for mobile speakers
                    utterance.volume = 1.0;
                } else {
                    utterance.rate = 1.1;
                    utterance.pitch = 1;
                    utterance.volume = 1.0;
                }
                
                // Error handling
                utterance.onerror = (event) => {
                    console.error('Speech synthesis error:', event.error);
                    if (callback) callback();
                };
                
                utterance.onend = () => {
                    if (callback) callback();
                };
                
                // Add small delay for mobile browsers
                setTimeout(() => {
                    try {
                        this.synth.speak(utterance);
                    } catch (error) {
                        console.error('Failed to speak:', error);
                        if (callback) callback();
                    }
                }, this.isMobile ? 100 : 0);
            }
            
            initializeSpeechRecognition() {
                if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                    this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    this.recognition.continuous = false;
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';
                    
                    this.recognition.onstart = () => this.onRecognitionStart();
                    this.recognition.onend = () => this.onRecognitionEnd();
                    this.recognition.onresult = (event) => this.onRecognitionResult(event);
                    this.recognition.onerror = (event) => this.onRecognitionError(event);
                } else {
                    this.showMessage('app', '‚ùå Speech recognition not supported in this browser. Please use Chrome.');
                    this.micButton.disabled = true;
                }
            }
            
            setupEventListeners() {
                this.micButton.addEventListener('click', () => this.toggleListening());
            }
            
            toggleListening() {
                if (this.isListening) {
                    this.recognition.stop();
                } else {
                    this.recognition.start();
                }
            }
            
            onRecognitionStart() {
                this.isListening = true;
                this.micButton.className = 'mic-button listening';
                this.statusText.textContent = 'Listening... Speak now';
                this.statusIndicator.className = 'status-indicator status-listening';
            }
            
            onRecognitionEnd() {
                this.isListening = false;
                this.micButton.className = 'mic-button';
                this.statusText.textContent = 'Ready to listen';
                this.statusIndicator.className = 'status-indicator status-ready';
            }
            
            onRecognitionResult(event) {
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    }
                }
                
                if (finalTranscript) {
                    const transcript = finalTranscript.toLowerCase().trim();
                    this.showMessage('user', transcript);
                    this.processUserInput(transcript);
                }
            }
            
            onRecognitionError(event) {
                this.showMessage('app', `‚ùå Error: ${event.error}. Please try again.`);
            }
            
            processUserInput(input) {
                this.statusIndicator.className = 'status-indicator status-processing';
                
                if (this.isListening) {
                    this.recognition.stop();
                }
                
                this.handleConversationFlow(input);
            }
            
            handleConversationFlow(input) {
                switch (this.conversationState) {
                    case 'waiting':
                        this.handleInitialInput(input);
                        break;
                        this.handleConfirmation(input);
                        break;
                    case 'get_task':
                        this.handleTaskInput(input);
                        break;
                    case 'get_time':
                        this.handleTimeInput(input);
                        break;
                    case 'get_date':
                        this.handleDateInput(input);
                        break;
                }
            }
            
            handleInitialInput(input) {
                if (input.includes('remind me that')) {
                    const content = input.replace('remind me that', '').trim();
                    this.processReminderContent(content);
                } else {
                    this.conversationState = 'confirm_reminder';
                    const message = 'ü§î Did you mean to set a reminder?';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            handleConfirmation(input) {
                if (input.includes('yes')) {
                    this.conversationState = 'get_task';
                    const message = '‚úÖ Great! Tell me what I should remind you about.';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else if (input.includes('no')) {
                    this.conversationState = 'waiting';
                    const message = 'üëç Alright. Whenever you need to set a reminder, just say "Remind me that..."';
                    this.showMessage('app', message);
                    this.speak(message);
                    this.statusIndicator.className = 'status-indicator status-ready';
                } else {
                    const message = 'ü§∑‚Äç‚ôÄÔ∏è Please say "yes" or "no".';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            handleTaskInput(input) {
                let task = input;
                if (task.includes('remind me')) {
                    task = task.replace(/remind me that/gi, '')
                               .replace(/remind me to/gi, '')
                               .replace(/remind me/gi, '')
                               .replace(/can you remind me/gi, '')
                               .replace(/could you remind me/gi, '')
                               .trim();
                }
                
                this.currentReminder.task = task;
                this.analyzeTimeAndDate(input);
            }
            
            handleTimeInput(input) {
                const timeInfo = this.extractTime(input);
                if (timeInfo) {
                    this.currentReminder.time = timeInfo;
                    if (!this.currentReminder.date) {
                        this.conversationState = 'get_date';
                        const message = 'üìÖ When should I remind you? (today, tomorrow, Monday, etc.)';
                        this.showMessage('app', message);
                        this.speak(message, () => {
                            this.startListeningAgain();
                        });
                    } else {
                        this.createReminder();
                    }
                } else {
                    const message = '‚è∞ I couldn\'t understand the time. Please say it again (e.g., "9 PM", "3:30 PM")';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            handleDateInput(input) {
                const dateInfo = this.extractDate(input);
                if (dateInfo) {
                    this.currentReminder.date = dateInfo;
                    if (!this.currentReminder.time) {
                        this.conversationState = 'get_time';
                        const message = '‚è∞ What time should I remind you?';
                        this.showMessage('app', message);
                        this.speak(message, () => {
                            this.startListeningAgain();
                        });
                    } else {
                        this.createReminder();
                    }
                } else {
                    const message = 'üìÖ I couldn\'t understand the date. Please say it again (e.g., "today", "tomorrow", "Monday")';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                }
            }
            
            startListeningAgain() {
                setTimeout(() => {
                    if (!this.isListening) {
                        this.recognition.start();
                    }
                }, 500);
            }
            
            processReminderContent(content) {
                this.currentReminder = { task: content };
                this.analyzeTimeAndDate(content);
            }
            
            analyzeTimeAndDate(content) {
                const timeInfo = this.extractTime(content);
                const dateInfo = this.extractDate(content);
                
                this.currentReminder.time = timeInfo;
                this.currentReminder.date = dateInfo;
                
                if (!timeInfo && !dateInfo) {
                    this.conversationState = 'get_time';
                    const message = '‚è∞ When and at what time should I remind you?';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else if (!timeInfo) {
                    this.conversationState = 'get_time';
                    const message = '‚è∞ What time should I remind you?';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else if (!dateInfo) {
                    this.conversationState = 'get_date';
                    const message = 'üìÖ When should I remind you?';
                    this.showMessage('app', message);
                    this.speak(message, () => {
                        this.startListeningAgain();
                    });
                } else {
                    this.createReminder();
                }
            }
            
            extractTime(text) {
                const timePatterns = [
                    /(\d{1,2}):(\d{2})\s*(am|pm)/i,
                    /(\d{1,2})\s*(am|pm)/i,
                    /(\d{1,2}):(\d{2})/,
                    /(\d{1,2})\s*o'?clock/i
                ];
                
                for (const pattern of timePatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        return match[0];
                    }
                }
                
                const spokenTimes = {
                    'nine': '9:00', 'ten': '10:00', 'eleven': '11:00', 'twelve': '12:00',
                    'one': '1:00', 'two': '2:00', 'three': '3:00', 'four': '4:00',
                    'five': '5:00', 'six': '6:00', 'seven': '7:00', 'eight': '8:00'
                };
                
                for (const [word, time] of Object.entries(spokenTimes)) {
                    if (text.includes(word)) {
                        const ampm = text.includes('pm') ? ' PM' : text.includes('am') ? ' AM' : '';
                        return time + ampm;
                    }
                }
                
                return null;
            }
            
            extractDate(text) {
                const lowerText = text.toLowerCase();
                
                const basicDates = [
                    'today', 'tomorrow', 'monday', 'tuesday', 'wednesday', 
                    'thursday', 'friday', 'saturday', 'sunday'
                ];
                
                for (const date of basicDates) {
                    if (lowerText.includes(date)) {
                        return date;
                    }
                }
                
                const daysMatch = lowerText.match(/(?:in\s*)?(\d+)\s*days?\s*(?:later|from\s*now|ahead)?|(\d+)\s*days?\s*later/);
                if (daysMatch) {
                    const days = parseInt(daysMatch[1] || daysMatch[2]);
                    return `${days} days later`;
                }
                
                const weeksMatch = lowerText.match(/(?:in\s*)?(\d+)\s*weeks?\s*(?:later|from\s*now|ahead)?|(\d+)\s*weeks?\s*later/);
                if (weeksMatch) {
                    const weeks = parseInt(weeksMatch[1] || weeksMatch[2]);
                    return `${weeks} weeks later`;
                }
                
                if (lowerText.includes('next week')) return 'next week';
                if (lowerText.includes('next month')) return 'next month';
                if (lowerText.includes('this week')) return 'this week';
                if (lowerText.includes('this weekend')) return 'this weekend';
                if (lowerText.includes('next weekend')) return 'next weekend';
                
                if (lowerText.includes('next monday')) return 'next monday';
                if (lowerText.includes('next tuesday')) return 'next tuesday';
                if (lowerText.includes('next wednesday')) return 'next wednesday';
                if (lowerText.includes('next thursday')) return 'next thursday';
                if (lowerText.includes('next friday')) return 'next friday';
                if (lowerText.includes('next saturday')) return 'next saturday';
                if (lowerText.includes('next sunday')) return 'next sunday';
                
                return null;
            }
            
            parseDateTime(dateStr, timeStr) {
                const now = new Date();
                let targetDate = new Date(now);
                
                if (dateStr) {
                    const lowerDate = dateStr.toLowerCase();
                    
                    if (lowerDate.includes('today')) {
                        // Keep current date
                    } else if (lowerDate.includes('tomorrow')) {
                        targetDate.setDate(targetDate.getDate() + 1);
                    } else if (lowerDate.includes('days later')) {
                        const daysMatch = lowerDate.match(/(\d+)\s*days?\s*later/);
                        if (daysMatch) {
                            const days = parseInt(daysMatch[1]);
                            targetDate.setDate(targetDate.getDate() + days);
                        }
                    } else if (lowerDate.includes('weeks later')) {
                        const weeksMatch = lowerDate.match(/(\d+)\s*weeks?\s*later/);
                        if (weeksMatch) {
                            const weeks = parseInt(weeksMatch[1]);
                            targetDate.setDate(targetDate.getDate() + (weeks * 7));
                        }
                    } else if (lowerDate.includes('next week')) {
                        targetDate.setDate(targetDate.getDate() + 7);
                    } else if (lowerDate.includes('next month')) {
                        targetDate.setMonth(targetDate.getMonth() + 1);
                    } else if (lowerDate.includes('this weekend')) {
                        const daysUntilSaturday = (6 - now.getDay()) % 7;
                        targetDate.setDate(targetDate.getDate() + daysUntilSaturday);
                    } else if (lowerDate.includes('next weekend')) {
                        const daysUntilSaturday = (6 - now.getDay()) % 7;
                        targetDate.setDate(targetDate.getDate() + daysUntilSaturday + 7);
                    } else {
                        const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                        
                        for (let i = 0; i < days.length; i++) {
                            if (lowerDate.includes(days[i])) {
                                const currentDay = now.getDay();
                                let daysUntil = (i - currentDay + 7) % 7;
                                
                                if (lowerDate.includes('next')) {
                                    daysUntil += 7;
                                } else if (daysUntil === 0) {
                                    daysUntil = 7;
                                }
                                
                                targetDate.setDate(targetDate.getDate() + daysUntil);
                                break;
                            }
                        }
                    }
                }
                
                if (timeStr) {
                    const timeMatch = timeStr.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i);
                    if (timeMatch) {
                        let hours = parseInt(timeMatch[1], 10);
                        const minutes = parseInt(timeMatch[2] || '0', 10);
                        const ampm = timeMatch[3] ? timeMatch[3].toLowerCase() : '';
                        
                        if (ampm === 'pm' && hours < 12) {
                            hours += 12;
                        } else if (ampm === 'am' && hours === 12) {
                            hours = 0;
                        }
                        
                        targetDate.setHours(hours, minutes, 0, 0);
                    }
                }
                
                return targetDate;
            }
            
            formatReminderDateTime(timestamp) {
                if (!timestamp) return 'N/A';
                
                const date = new Date(timestamp);
                const options = {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true,
                    timeZoneName: 'short'
                };
                
                return date.toLocaleString(undefined, options);
            }
            
            createReminder() {
                const reminderDateTime = this.parseDateTime(this.currentReminder.date, this.currentReminder.time);
                
                const reminder = {
                    id: Date.now(),
                    task: this.currentReminder.task,
                    time: this.currentReminder.time,
                    date: this.currentReminder.date,
                    timestamp: reminderDateTime.getTime(),
                    timezone: this.userTimezone,
                    created: new Date().toLocaleString(),
                    location: this.userLocation
                };
                
                const isDuplicate = this.reminders.some(existing => 
                    existing.task === reminder.task && 
                    existing.timestamp === reminder.timestamp
                );
                
                if (isDuplicate) {
                    const message = '‚ö†Ô∏è This reminder already exists!';
                    this.showMessage('app', message);
                    this.speak(message);
                    this.resetState();
                    return;
                }
                
                this.reminders.push(reminder);
                localStorage.setItem('reminders', JSON.stringify(this.reminders));
                
                const formattedDateTime = this.formatReminderDateTime(reminder.timestamp);
                const message = `‚úÖ Perfect! I've created your reminder: "${reminder.task}" for ${formattedDateTime}.`;
                this.showMessage('app', message);
                this.speak(message);
                
                this.updateRemindersDisplay();
                this.updateStats();
                this.resetState();
                this.statusIndicator.className = 'status-indicator status-ready';
            }
            
            resetState() {
                this.conversationState = 'waiting';
                this.currentReminder = {};
            }
            
            showMessage(sender, message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}-message`;
                messageDiv.textContent = message;
                this.conversationDisplay.appendChild(messageDiv);
                this.conversationDisplay.scrollTop = this.conversationDisplay.scrollHeight;
            }
            
            updateRemindersDisplay() {
                if (this.reminders.length === 0) {
                    this.remindersList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÖ</div>
                            <p class="font-medium">No reminders yet</p>
                            <p class="text-sm opacity-75">Create your first reminder using voice commands</p>
                        </div>
                    `;
                } else {
                    this.remindersList.innerHTML = this.reminders.map(reminder => {
                        const formattedTime = reminder.timestamp ? 
                            this.formatReminderDateTime(reminder.timestamp) : 
                            `${reminder.date} at ${reminder.time}`;
                        
                        const timeUntil = reminder.timestamp ? this.getTimeUntilReminder(reminder.timestamp) : '';
                        
                        return `
                            <div class="reminder-card" id="reminder-${reminder.id}">
                                <div class="flex items-start justify-between">
                                    <div class="flex-1">
                                        <h4 class="font-semibold text-gray-900 text-lg mb-2">${reminder.task}</h4>
                                        <p class="text-gray-600 text-sm flex items-center gap-2">
                                            <span>üìÖ</span>
                                            ${formattedTime}
                                        </p>
                                        ${timeUntil ? `<div class="countdown-badge">${timeUntil}</div>` : ''}
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <div class="text-2xl opacity-50">‚è∞</div>
                                        <button 
                                            class="delete-btn"
                                            onclick="app.deleteReminder(${reminder.id})"
                                            title="Delete reminder"
                                        >
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                </div>
                                <div class="reminder-meta">
                                    <div class="flex items-center justify-between text-xs">
                                        <span>Created: ${reminder.created}</span>
                                        ${reminder.timezone ? `<span class="flex items-center gap-1"><span>üåç</span>${reminder.timezone}</span>` : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            }
            
            getTimeUntilReminder(timestamp) {
                const now = new Date().getTime();
                const diff = timestamp - now;
                
                if (diff < 0) return '‚è∞ Overdue';
                
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                
                if (days > 0) return `‚è≥ In ${days}d ${hours}h`;
                if (hours > 0) return `‚è≥ In ${hours}h ${minutes}m`;
                if (minutes > 0) return `‚è≥ In ${minutes}m`;
                return 'üî• Any moment now!';
            }
            
            updateStats() {
                const total = this.reminders.length;
                const upcoming = this.reminders.filter(r => r.timestamp > new Date().getTime()).length;
                
                document.getElementById('totalReminders').textContent = total;
                document.getElementById('upcomingReminders').textContent = upcoming;
            }
            
            deleteReminder(id) {
                const reminder = this.reminders.find(r => r.id === id);
                if (reminder) {
                    this.pendingDeleteId = id;
                    this.deleteMessage.textContent = `Are you sure you want to delete "${reminder.task}"?`;
                    this.deleteModal.classList.add('show');
                }
            }
            
            confirmDelete() {
                if (this.pendingDeleteId) {
                    this.reminders = this.reminders.filter(r => r.id !== this.pendingDeleteId);
                    localStorage.setItem('reminders', JSON.stringify(this.reminders));
                    
                    const reminderCard = document.getElementById(`reminder-${this.pendingDeleteId}`);
                    if (reminderCard) {
                        reminderCard.style.transform = 'translateX(-100%)';
                        reminderCard.style.opacity = '0';
                        
                        setTimeout(() => {
                            this.updateRemindersDisplay();
                            this.updateStats();
                        }, 300);
                    } else {
                        this.updateRemindersDisplay();
                        this.updateStats();
                    }
                    
                    this.showMessage('app', '‚úÖ Reminder deleted successfully!');
                    this.speak('Reminder deleted successfully!');
                    
                    this.cancelDelete();
                }
            }
            
            cancelDelete() {
                this.deleteModal.classList.remove('show');
                this.pendingDeleteId = null;
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            app = new RemindMeApp();
        });
    </script>
</body>
</html>
